<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React 基础 | 云息的面试资料库</title>
    <meta name="description" content="Code for a better world!">
    <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="apple-mobile-web-app-status-bar-style">
    
    <link rel="preload" href="/assets/css/0.styles.05cc7eb5.css" as="style"><link rel="preload" href="/assets/js/app.dcf74adf.js" as="script"><link rel="preload" href="/assets/js/3.d459fbac.js" as="script"><link rel="preload" href="/assets/js/36.8e1c8cef.js" as="script"><link rel="preload" href="/assets/js/6.da654ace.js" as="script"><link rel="prefetch" href="/assets/js/10.726ceeda.js"><link rel="prefetch" href="/assets/js/11.cc1411d8.js"><link rel="prefetch" href="/assets/js/12.2d961c16.js"><link rel="prefetch" href="/assets/js/13.4534349c.js"><link rel="prefetch" href="/assets/js/14.25b1e7f3.js"><link rel="prefetch" href="/assets/js/15.9a2ebaed.js"><link rel="prefetch" href="/assets/js/16.2e7b832c.js"><link rel="prefetch" href="/assets/js/17.c3355b63.js"><link rel="prefetch" href="/assets/js/18.853dd12d.js"><link rel="prefetch" href="/assets/js/19.d6bc92e9.js"><link rel="prefetch" href="/assets/js/20.79e63114.js"><link rel="prefetch" href="/assets/js/21.5b26b4a7.js"><link rel="prefetch" href="/assets/js/22.f545d988.js"><link rel="prefetch" href="/assets/js/23.1ef08a80.js"><link rel="prefetch" href="/assets/js/24.52c1504b.js"><link rel="prefetch" href="/assets/js/25.b85c6c7a.js"><link rel="prefetch" href="/assets/js/26.7e1ce755.js"><link rel="prefetch" href="/assets/js/27.b76dc2c4.js"><link rel="prefetch" href="/assets/js/28.728d4234.js"><link rel="prefetch" href="/assets/js/29.b0d656bb.js"><link rel="prefetch" href="/assets/js/30.86cd0a9c.js"><link rel="prefetch" href="/assets/js/31.18f13b4e.js"><link rel="prefetch" href="/assets/js/32.83a55f7d.js"><link rel="prefetch" href="/assets/js/33.8c2cb966.js"><link rel="prefetch" href="/assets/js/34.749d688a.js"><link rel="prefetch" href="/assets/js/35.0a7990df.js"><link rel="prefetch" href="/assets/js/37.34ec6faf.js"><link rel="prefetch" href="/assets/js/38.8f5ef488.js"><link rel="prefetch" href="/assets/js/39.d32ba925.js"><link rel="prefetch" href="/assets/js/4.79676fe3.js"><link rel="prefetch" href="/assets/js/40.17ab7d00.js"><link rel="prefetch" href="/assets/js/41.68be4954.js"><link rel="prefetch" href="/assets/js/42.da32c428.js"><link rel="prefetch" href="/assets/js/43.3f651e5b.js"><link rel="prefetch" href="/assets/js/44.7e0185a5.js"><link rel="prefetch" href="/assets/js/45.309ead5b.js"><link rel="prefetch" href="/assets/js/46.6f7aeb62.js"><link rel="prefetch" href="/assets/js/47.361ce141.js"><link rel="prefetch" href="/assets/js/48.e6d8a8f3.js"><link rel="prefetch" href="/assets/js/49.33d9f0ac.js"><link rel="prefetch" href="/assets/js/5.51d5e42c.js"><link rel="prefetch" href="/assets/js/50.8b8c70c1.js"><link rel="prefetch" href="/assets/js/51.27f1ce7d.js"><link rel="prefetch" href="/assets/js/52.64320734.js"><link rel="prefetch" href="/assets/js/53.c732a5fa.js"><link rel="prefetch" href="/assets/js/54.541148e9.js"><link rel="prefetch" href="/assets/js/55.36cb41de.js"><link rel="prefetch" href="/assets/js/56.14a7959d.js"><link rel="prefetch" href="/assets/js/57.6a5f2316.js"><link rel="prefetch" href="/assets/js/58.1707cf09.js"><link rel="prefetch" href="/assets/js/59.176b3d1a.js"><link rel="prefetch" href="/assets/js/60.fbfd06af.js"><link rel="prefetch" href="/assets/js/61.c2d4f52a.js"><link rel="prefetch" href="/assets/js/62.0952ea43.js"><link rel="prefetch" href="/assets/js/63.40b1da1b.js"><link rel="prefetch" href="/assets/js/64.a4581053.js"><link rel="prefetch" href="/assets/js/65.72c37f85.js"><link rel="prefetch" href="/assets/js/66.33de2ae0.js"><link rel="prefetch" href="/assets/js/7.aa6f379f.js"><link rel="prefetch" href="/assets/js/8.d5676b08.js"><link rel="prefetch" href="/assets/js/9.e418b8d5.js"><link rel="prefetch" href="/assets/js/vendors~notification.7bcb2342.js">
    <link rel="stylesheet" href="/assets/css/0.styles.05cc7eb5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">云息的面试资料库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fedoc/" class="nav-link router-link-active">指南</a></div><div class="nav-item"><a href="http://yunxi.site/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/xiaomuzhu/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fedoc/" class="nav-link router-link-active">指南</a></div><div class="nav-item"><a href="http://yunxi.site/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/xiaomuzhu/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>01-计算机网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/01-计算机网络/CDN和DNS.html" class="sidebar-link">CDN 和 DNS</a></li><li><a href="/fedoc/01-计算机网络/HTTP.html" class="sidebar-link">HTTP</a></li><li><a href="/fedoc/01-计算机网络/前端缓存最佳实践.html" class="sidebar-link">前端缓存最佳实践</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>02-CSS&amp;HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/02-CSS&amp;HTML/CSS 基础.html" class="sidebar-link">CSS 基础</a></li><li><a href="/fedoc/02-CSS&amp;HTML/HTML.html" class="sidebar-link">HTML</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>03-JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/03-JavaScript/JS 继承的八种写法.html" class="sidebar-link">JS 继承的八种写法</a></li><li><a href="/fedoc/03-JavaScript/JS异步编程原理.html" class="sidebar-link">JavaScript 异步编程原理</a></li><li><a href="/fedoc/03-JavaScript/JavaScript基础.html" class="sidebar-link">JS 基础</a></li><li><a href="/fedoc/03-JavaScript/异步-手写async_await.html" class="sidebar-link">异步—手写 async_await</a></li><li><a href="/fedoc/03-JavaScript/异步编程专题.html" class="sidebar-link">JS 异步编程：种类和原理</a></li><li><a href="/fedoc/03-JavaScript/手写系列.html" class="sidebar-link">手写系列</a></li><li><a href="/fedoc/03-JavaScript/防抖节流.html" class="sidebar-link">JavaScript防抖、节流以及rAF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>04-游览器与BOM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/04-游览器与BOM/Cookie-Session ,JWT认证机制.html" class="sidebar-link">浅谈 Cookie-Session 、Jwt 两种身份认证机制</a></li><li><a href="/fedoc/04-游览器与BOM/Session的概念和安全问题.html" class="sidebar-link">有关 Session 的那些事儿</a></li><li><a href="/fedoc/04-游览器与BOM/V8优化之对象中的快属性与慢属性.html" class="sidebar-link">V8 优化之对象中的快属性与慢属性</a></li><li><a href="/fedoc/04-游览器与BOM/Web Storage 总结.html" class="sidebar-link">Cookie, Session, Web Storage与IndexedDB 总结</a></li><li><a href="/fedoc/04-游览器与BOM/前端安全.html" class="sidebar-link">前端安全</a></li><li><a href="/fedoc/04-游览器与BOM/前端路由的原理.html" class="sidebar-link">前端路由原理及实现</a></li><li><a href="/fedoc/04-游览器与BOM/原生事件.html" class="sidebar-link">原生事件</a></li><li><a href="/fedoc/04-游览器与BOM/跨域.html" class="sidebar-link">跨域</a></li><li><a href="/fedoc/04-游览器与BOM/输入URL1—输入URL和DNS_TCP_HTTP.html" class="sidebar-link">URL1—输入 URL 和游览器</a></li><li><a href="/fedoc/04-游览器与BOM/输入URL2—网络篇.html" class="sidebar-link">URL2—网络篇</a></li><li><a href="/fedoc/04-游览器与BOM/输入URL3—渲染树形成+原理.html" class="sidebar-link">URL3—渲染树形成+原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>05-React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/05-React/React基础.html" class="active sidebar-link">React 基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#react-最新的生命周期是怎样的" class="sidebar-link">React 最新的生命周期是怎样的?</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#ajax-应该放在哪个生命周期中？" class="sidebar-link">ajax 应该放在哪个生命周期中？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#diff-算法做了哪些优化？" class="sidebar-link">diff 算法做了哪些优化？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#shouldcomponentupdate-如何配合性能优化" class="sidebar-link">shouldComponentUpdate 如何配合性能优化</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#react-中-keys-的作用是什么？" class="sidebar-link">React 中 keys 的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#函数组件和-class-组件的区别？" class="sidebar-link">函数组件和 class 组件的区别？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#setstate-后发生了什么" class="sidebar-link">setState 后发生了什么?</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#setstate-到底是异步还是同步" class="sidebar-link">setState 到底是异步还是同步?</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#hoc-解决了什么问题？" class="sidebar-link">HOC 解决了什么问题？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#state-和-props-有什么区别？" class="sidebar-link">state 和 props 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#purecomponent-纯组件-和-memo" class="sidebar-link">PureComponent 纯组件 和 memo</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#什么是受控组件？" class="sidebar-link">什么是受控组件？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#react-router-如何配置懒加载？" class="sidebar-link">react-router 如何配置懒加载？</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#何为-fiber" class="sidebar-link">何为 fiber</a></li><li class="sidebar-sub-header"><a href="/fedoc/05-React/React基础.html#react-性能优化" class="sidebar-link">React 性能优化</a></li></ul></li><li><a href="/fedoc/05-React/React进阶.html" class="sidebar-link">React 进阶</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>06-前端工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/06-前端工程化/Babel 工作原理.html" class="sidebar-link">Babel 是如何转换代码的？</a></li><li><a href="/fedoc/06-前端工程化/Git.html" class="sidebar-link">Git 相关</a></li><li><a href="/fedoc/06-前端工程化/webpack 的工作原理.html" class="sidebar-link">webpack 的工作原理</a></li><li><a href="/fedoc/06-前端工程化/webpack.html" class="sidebar-link">从零搭建 React 开发环境</a></li><li><a href="/fedoc/06-前端工程化/实现一个简易的webpack可选链loader.html" class="sidebar-link">optional-chaining-loader</a></li><li><a href="/fedoc/06-前端工程化/性能优化总结.html" class="sidebar-link">性能优化总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>07-前端架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/07-前端架构/Node秒杀系统架构.html" class="sidebar-link">Node 秒杀系统架构</a></li><li><a href="/fedoc/07-前端架构/前端监控和埋点方案设计.html" class="sidebar-link">前端监控和前端埋点方案设计</a></li><li><a href="/fedoc/07-前端架构/支付宝架构师眼里的高并发架构.html" class="sidebar-link">支付宝架构师眼里的高并发架构</a></li><li><a href="/fedoc/07-前端架构/架构要考虑什么.html" class="sidebar-link">做架构要考虑什么？</a></li><li><a href="/fedoc/07-前端架构/说说前后端分离.html" class="sidebar-link">说说前后端分离</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>08-Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/08-Node/Koa2深度解析.html" class="sidebar-link">Koa2 深度解析</a></li><li><a href="/fedoc/08-Node/Koa2源码和原理浅析.html" class="sidebar-link">Koa源码系列1—手写 Koa 库</a></li><li><a href="/fedoc/08-Node/Node.js多进程底层原理.html" class="sidebar-link">Node.js 多进程底层原理</a></li><li><a href="/fedoc/08-Node/Node.js调试之内存泄漏篇.html" class="sidebar-link">Node.js 调试之内存泄漏篇</a></li><li><a href="/fedoc/08-Node/初探 Node.js 中的事件循环.html" class="sidebar-link">初探 Node.js 中的事件循环</a></li><li><a href="/fedoc/08-Node/操作系统.html" class="sidebar-link">操作系统</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>09-算法和数据结构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/09-算法和数据结构/算法.html" class="sidebar-link">算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>10-知识广度</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/10-知识广度/200409如何在数据库中存储密码更安全.html" class="sidebar-link">如何在数据库中存储密码更安全？</a></li><li><a href="/fedoc/10-知识广度/200410如何设计一个良好的API接口.html" class="sidebar-link">如何设计一个良好的 API 接口？</a></li><li><a href="/fedoc/10-知识广度/200411二维码扫描登录是什么原理.html" class="sidebar-link">二维码扫描登录是什么原理？</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react-基础"><a href="#react-基础" aria-hidden="true" class="header-anchor">#</a> React 基础</h1> <h2 id="react-最新的生命周期是怎样的"><a href="#react-最新的生命周期是怎样的" aria-hidden="true" class="header-anchor">#</a> React 最新的生命周期是怎样的?</h2> <p><a href="https://juejin.im/post/5b6f1800f265da282d45a79a#heading-0" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="挂载阶段"><a href="#挂载阶段" aria-hidden="true" class="header-anchor">#</a> 挂载阶段</h3> <ul><li>constructor</li> <li>getDerivedStateFromProps</li> <li>UNSAVE_componentWillMount 组件即将被装载、渲染到页面上</li> <li>render 组件在这里生成虚拟的<code>DOM</code>节点</li> <li>componentDidMount 组件真正在被装载之后</li></ul> <h3 id="更新阶段"><a href="#更新阶段" aria-hidden="true" class="header-anchor">#</a> 更新阶段</h3> <p>更新阶段，当组件的 props 改变了，或组件内部调用了 setState 或者 forceUpdate 发生，会发生多次</p> <ul><li>UNSAFE_componentWillReceiveProps 组件将要接收到属性的时候调用</li> <li>getDerivedStateFromProps</li> <li>shouldComponentUpdate</li> <li>UNSAFE_componentWillUpdate 组件即将更新不能修改属性和状态</li> <li>render</li> <li>getSnapshotBeforeUpdate</li> <li>componentDidUpdate</li></ul> <h3 id="卸载阶段"><a href="#卸载阶段" aria-hidden="true" class="header-anchor">#</a> 卸载阶段</h3> <ul><li>componentWillUnmount</li></ul> <p>当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的 DOM 元素等垃圾清理工作</p> <p>注意不要在这个函数里去调用 setState，因为组件不会重新渲染了</p> <h2 id="ajax-应该放在哪个生命周期中？"><a href="#ajax-应该放在哪个生命周期中？" aria-hidden="true" class="header-anchor">#</a> ajax 应该放在哪个生命周期中？</h2> <ul><li><code>React</code> 下一代调和算法 <code>Fiber</code> 会通过开始或停止渲染的方式优化应用性能，其会影响到 <code>componentWillMount</code> 的触发次数。对于 <code>componentWillMount</code> 这个生命周期函数的调用次数会变得不确定，<code>React</code> 可能会多次频繁调用 <code>componentWillMount</code>。如果我们将 <code>AJAX</code> 请求放到 <code>componentWillMount</code> 函数中，那么可能会被触发多次，自然也就不是好的选择。</li> <li>如果我们将<code>AJAX</code> 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了<code>setState</code>函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 <code>componentDidMount</code> 函数中进行 <code>AJAX</code> 请求则能有效避免这个问题</li></ul> <h2 id="diff-算法做了哪些优化？"><a href="#diff-算法做了哪些优化？" aria-hidden="true" class="header-anchor">#</a> diff 算法做了哪些优化？</h2> <ul><li>把树形结构按照层级分解，只比较同级元素。</li> <li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li> <li><code>React</code> 只会匹配相同 tag 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li> <li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li> <li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul> <h2 id="shouldcomponentupdate-如何配合性能优化"><a href="#shouldcomponentupdate-如何配合性能优化" aria-hidden="true" class="header-anchor">#</a> shouldComponentUpdate 如何配合性能优化</h2> <p><strong>scu 有什么用？背后逻辑是什么？</strong></p> <ul><li>默认返回 true。父组件更新，所有子组件无条件更新</li></ul> <p><strong>既然 scu 这么好，为什么还给你提供自定义的能力，不给他直接实现到框架内部呢？</strong></p> <ul><li>因为一定要配合不可变值</li> <li>所以有的开发者会使用不合规范的写法，导致不发生重渲染</li></ul> <p><strong>比较的时候如何有什么要注意的问题？</strong></p> <ul><li>用_.isEqual JSON.stringfy() 深度比较会非常耗费性能</li> <li>所以设计 state 的时候不要层级太深</li> <li>使用浅比较，浅比较已经适用大部分情况了</li> <li>另外可以自定义比较</li></ul> <p>当然如果真的想完整对比当前 <code>state</code> 和之前的 <code>state</code> 是否相同，并且不影响性能也是行得通的，可以通过 <code>immutable</code> 或者 <code>immer</code> 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 <code>state</code> 是否一致也就方便多了，同时也很推荐阅读下 <code>immer</code> 的源码实现。</p> <ul><li>彻底拥抱不可变值</li> <li>解决了什么问题？深拷贝性能太差，immutable.js 基于共享数据和结构，性能好</li> <li>有一定学习和使用成本</li> <li><a href="https://github.com/mweststrate/immer" target="_blank" rel="noopener noreferrer">Immer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是 mobx 的作者写的一个 immutable 库，核心实现是利用 ES6 的 proxy，几乎以最小的成本实现了 js 的不可变数据结构</li></ul> <h2 id="react-中-keys-的作用是什么？"><a href="#react-中-keys-的作用是什么？" aria-hidden="true" class="header-anchor">#</a> React 中 keys 的作用是什么？</h2> <p><code>Keys</code>是 <code>React</code> 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识</p> <ul><li>在开发过程中，我们需要保证某个元素的 <code>key</code> 在其同级元素中具有唯一性。在 <code>React Diff</code> 算法中<code>React</code> 会借助元素的 <code>Key</code> 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 <code>Key</code> 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 <code>Key</code> 的重要性</li></ul> <h2 id="函数组件和-class-组件的区别？"><a href="#函数组件和-class-组件的区别？" aria-hidden="true" class="header-anchor">#</a> 函数组件和 class 组件的区别？</h2> <ul><li>纯函数，输入 props，输出 JSX</li> <li>没有实例，没有生命周期，没有 state</li> <li>不能拓展其他方法</li></ul> <h2 id="setstate-后发生了什么"><a href="#setstate-后发生了什么" aria-hidden="true" class="header-anchor">#</a> setState 后发生了什么?</h2> <p>当给 setState 传入新对象时，React 内部会进行一种类似 Object.assign() 的方式对象合并，把需要更新的 state 合并后放入状态队列，利用这个队列可以更加高效的批量更新 state；当参数为函数时，React 会将所有更新组成队列，并且按顺序来执行，这样避免了将 state 合并成一个对象的问题，之后会启动一个<code>reconciliation</code>调和过程，即创建一个新的 React Element tree（UI 层面的对象表示）并且和之前的 tree 作比较，基于你传递给 setState 的对象找出发生的变化，最后更新 DOM 中需改动的部分。</p> <p><img src="https://tva1.sinaimg.cn/large/0082zybply1gc9gqugd88j30ht0cemz9.jpg" alt="image-20200226074600085"></p> <h2 id="setstate-到底是异步还是同步"><a href="#setstate-到底是异步还是同步" aria-hidden="true" class="header-anchor">#</a> setState 到底是异步还是同步?</h2> <p>看右边，开始处于 <code>batchUpdate</code> 中，<code>isBatchingUpdates = true</code>，接着开始执行 <code>setTimeout</code>，但是里面的 <code>setState</code> 是异步的，所以还没执行，紧接着 <code>isBatchingUpdates = false</code> 。因此之后 <code>setState</code> 执行的时候，<code>isBatchingUpdates = false</code> ，所以开始走流程图的右边了。</p> <ul><li>同步异步不是由 setState 自己决定的</li> <li>就是看能否命中 batchUpdate 机制</li> <li>判断 <code>isBatchingUpdate</code></li></ul> <p><strong>能命中 batchUpdate 机制：</strong></p> <ul><li>生命周期以及其调用的函数</li> <li>React 中注册的事件（和它调用的函数）</li> <li>React 可以“管理”的入口</li></ul> <p><strong>不能命中：</strong></p> <ul><li>setTimeout，setInterval（和它调用的函数）</li> <li>自定义的 DOM 事件</li> <li>React “管不到” 的入口，不是 React 那儿注册的</li></ul> <h2 id="hoc-解决了什么问题？"><a href="#hoc-解决了什么问题？" aria-hidden="true" class="header-anchor">#</a> HOC 解决了什么问题？</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> b
<span class="token punctuation">}</span>
</code></pre></div><p>现在如果我想给这个 <code>add</code> 函数添加一个输出结果的功能，那么你可能会考虑我直接使用 <code>console.log</code> 不就实现了么。说的没错，但是如果我们想做的<strong>更加优雅并且容易复用和扩展</strong>，我们可以这样去做</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">withLog</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> wrapper
<span class="token punctuation">}</span>
<span class="token keyword">const</span> withLogAdd <span class="token operator">=</span> <span class="token function">withLog</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>
<span class="token function">withLogAdd</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>其实这个做法在函数式编程里称之为高阶函数，大家都知道 <code>React</code> 的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。</li> <li>其实 <code>HOC</code> 和 <code>Vue</code> 中的 <code>mixins</code> 作用是一致的，并且在早期 <code>React</code> 也是使用 <code>mixins</code> 的方式。但是在使用 <code>class</code> 的方式创建组件以后，<code>mixins</code> 的方式就不能使用了，并且其实 <code>mixins</code> 也是存在一些问题的，比如</li></ul> <ol><li>隐含了一些依赖，比如我在组件中写了某个 <code>state</code> 并且在 <code>mixin</code> 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 <code>mixin</code> 中查找依赖</li> <li>多个 <code>mixin</code> 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。</li> <li>雪球效应，虽然我一个组件还是使用着同一个 <code>mixin</code>，但是一个 <code>mixin</code> 会被多个组件使用，可能会存在需求使得 <code>mixin</code> 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本</li></ol> <blockquote><p><code>HOC</code> 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）</p></blockquote> <p>抽离多个组件的公共逻辑</p> <ul><li>HOC</li> <li>Render Props</li></ul> <h2 id="state-和-props-有什么区别？"><a href="#state-和-props-有什么区别？" aria-hidden="true" class="header-anchor">#</a> state 和 props 有什么区别？</h2> <p>一句话概括，props 是组件对外的接口，state 是组件对内的接口。</p> <p><code>state</code> 的主要作用是用于组件保存、控制、修改<em>自己</em>的可变状态。<code>state</code> 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 <code>state</code> 是一个局部的、只能被组件自身控制的数据源。<code>state</code> 中状态可以通过 <code>this.setState</code> 方法进行更新，<code>setState</code> 会导致组件的重新渲染。</p> <p><code>props</code> 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。</p> <p><code>state</code> 和 <code>props</code> 有着千丝万缕的关系。它们都可以决定组件的行为和显示形态。一个组件的 <code>state</code> 中的数据可以通过 <code>props</code> 传给子组件，一个组件可以使用外部传入的 <code>props</code> 来初始化自己的 <code>state</code>。但是它们的职责其实非常明晰分明：<em><code>state</code> 是让组件控制自己的状态，<code>props</code> 是让外部对组件自己进行配置</em>。</p> <p>如果你觉得还是搞不清 <code>state</code> 和 <code>props</code> 的使用场景，那么请记住一个简单的规则：尽量少地用 <code>state</code>，尽量多地用 <code>props</code>。</p> <p>没有 <code>state</code> 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。前端应用状态管理是一个复杂的问题，我们后续会继续讨论。</p> <table><thead><tr><th style="text-align:left;">场景</th> <th style="text-align:left;">props</th> <th style="text-align:left;">state</th></tr></thead> <tbody><tr><td style="text-align:left;">是否可以从父组件中获取初始值</td> <td style="text-align:left;">可以</td> <td style="text-align:left;">可以</td></tr> <tr><td style="text-align:left;">是否能被父组件改变</td> <td style="text-align:left;">可以</td> <td style="text-align:left;">不可以</td></tr> <tr><td style="text-align:left;">是否能设置默认值</td> <td style="text-align:left;">可以</td> <td style="text-align:left;">不可以</td></tr> <tr><td style="text-align:left;">是否在组件里改变值</td> <td style="text-align:left;">不可以</td> <td style="text-align:left;">可以</td></tr> <tr><td style="text-align:left;">能否给子组件设置初始值</td> <td style="text-align:left;">可以</td> <td style="text-align:left;">可以</td></tr> <tr><td style="text-align:left;">能否在子组件里被改变值</td> <td style="text-align:left;">可以</td> <td style="text-align:left;">可以</td></tr></tbody></table> <p><strong>总结一下</strong>：</p> <ol><li>props 用于定义外部接口，使用 state 来存储控制当前页面逻辑的数据；</li> <li>props 的赋值是在父级组件，state 赋值在当前组件内部；</li> <li>props 是不可变的，而 state 是可变的；</li> <li>使用 props 比 state 会有更好的性能；</li></ol> <h2 id="purecomponent-纯组件-和-memo"><a href="#purecomponent-纯组件-和-memo" aria-hidden="true" class="header-anchor">#</a> PureComponent 纯组件 和 memo</h2> <ul><li>PureComponent，memo 实现了 SCU 中的浅比较（只比较第一层）</li> <li>memo 就是 PC 的函数组件版本</li> <li>必须配合不可变值</li></ul> <h2 id="什么是受控组件？"><a href="#什么是受控组件？" aria-hidden="true" class="header-anchor">#</a> 什么是受控组件？</h2> <ul><li>表单的值，受 state 控制</li> <li>需要自行监听 onChange 事件</li> <li>对比非受控组件</li></ul> <h2 id="react-router-如何配置懒加载？"><a href="#react-router-如何配置懒加载？" aria-hidden="true" class="header-anchor">#</a> react-router 如何配置懒加载？</h2> <p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcy3v85jpwj30tb0fsgtu.jpg" alt="image-20200318151935024"></p> <h2 id="何为-fiber"><a href="#何为-fiber" aria-hidden="true" class="header-anchor">#</a> 何为 fiber</h2> <p>js 的单线程调度算法</p> <p><a href="https://juejin.im/post/5ab7b3a2f265da2378403e57" target="_blank" rel="noopener noreferrer">fiber 介绍<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>react 在进行组件渲染时，从 setState 开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js 执行会占据主线程时间较长，会导致页面响应度变差，使得 react 在动画、手势等应用中效果比较差。</p> <p>为了解决这个问题，react 团队经过两年的工作，重写了 react 中核心算法——<a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer">reconciliation<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。并在 v16 版本中发布了这个新的特性。为了区别之前和之后的 reconciler，通常将之前的 reconciler 称为 stack reconciler，重写后的称为 fiber reconciler，简称为 Fiber。</p> <ul><li>将 reconciliation（重写了） 阶段进行拆分（commit 无法拆分，一次执行完）</li> <li>DOM 需要渲染时候暂停，空闲时恢复</li> <li>何时暂停何时恢复呢？ <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">window.requestIdleCallback<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> (Edge,IE,Safari 不支持，用 polyfill)</li></ul> <h2 id="react-性能优化"><a href="#react-性能优化" aria-hidden="true" class="header-anchor">#</a> React 性能优化</h2> <ul><li>减少 bind this</li> <li>合理使用 SCU，Pure 和 memo</li> <li>webpack 层面的优化</li> <li>前端通用的，比如图片懒加载，base64，CSS</li> <li>使用 SSR</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/xiaomuzhu/front-end-interview/edit/master/fedoc/05-React/React基础.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/fedoc/04-游览器与BOM/输入URL3—渲染树形成+原理.html" class="prev">
          URL3—渲染树形成+原理
        </a></span> <span class="next"><a href="/fedoc/05-React/React进阶.html">
          React 进阶
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.dcf74adf.js" defer></script><script src="/assets/js/3.d459fbac.js" defer></script><script src="/assets/js/36.8e1c8cef.js" defer></script><script src="/assets/js/6.da654ace.js" defer></script>
  </body>
</html>
