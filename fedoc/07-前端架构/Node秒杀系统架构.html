<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Node 秒杀系统架构 | 云息的面试资料库</title>
    <meta name="description" content="Code for a better world!">
    <link rel="icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#3eaf7c">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="apple-mobile-web-app-status-bar-style">
    
    <link rel="preload" href="/assets/css/0.styles.05cc7eb5.css" as="style"><link rel="preload" href="/assets/js/app.dcf74adf.js" as="script"><link rel="preload" href="/assets/js/3.d459fbac.js" as="script"><link rel="preload" href="/assets/js/44.7e0185a5.js" as="script"><link rel="preload" href="/assets/js/6.da654ace.js" as="script"><link rel="prefetch" href="/assets/js/10.726ceeda.js"><link rel="prefetch" href="/assets/js/11.cc1411d8.js"><link rel="prefetch" href="/assets/js/12.2d961c16.js"><link rel="prefetch" href="/assets/js/13.4534349c.js"><link rel="prefetch" href="/assets/js/14.25b1e7f3.js"><link rel="prefetch" href="/assets/js/15.9a2ebaed.js"><link rel="prefetch" href="/assets/js/16.2e7b832c.js"><link rel="prefetch" href="/assets/js/17.c3355b63.js"><link rel="prefetch" href="/assets/js/18.853dd12d.js"><link rel="prefetch" href="/assets/js/19.d6bc92e9.js"><link rel="prefetch" href="/assets/js/20.79e63114.js"><link rel="prefetch" href="/assets/js/21.5b26b4a7.js"><link rel="prefetch" href="/assets/js/22.f545d988.js"><link rel="prefetch" href="/assets/js/23.1ef08a80.js"><link rel="prefetch" href="/assets/js/24.52c1504b.js"><link rel="prefetch" href="/assets/js/25.b85c6c7a.js"><link rel="prefetch" href="/assets/js/26.7e1ce755.js"><link rel="prefetch" href="/assets/js/27.b76dc2c4.js"><link rel="prefetch" href="/assets/js/28.728d4234.js"><link rel="prefetch" href="/assets/js/29.b0d656bb.js"><link rel="prefetch" href="/assets/js/30.86cd0a9c.js"><link rel="prefetch" href="/assets/js/31.18f13b4e.js"><link rel="prefetch" href="/assets/js/32.83a55f7d.js"><link rel="prefetch" href="/assets/js/33.8c2cb966.js"><link rel="prefetch" href="/assets/js/34.749d688a.js"><link rel="prefetch" href="/assets/js/35.0a7990df.js"><link rel="prefetch" href="/assets/js/36.8e1c8cef.js"><link rel="prefetch" href="/assets/js/37.34ec6faf.js"><link rel="prefetch" href="/assets/js/38.8f5ef488.js"><link rel="prefetch" href="/assets/js/39.d32ba925.js"><link rel="prefetch" href="/assets/js/4.79676fe3.js"><link rel="prefetch" href="/assets/js/40.17ab7d00.js"><link rel="prefetch" href="/assets/js/41.68be4954.js"><link rel="prefetch" href="/assets/js/42.da32c428.js"><link rel="prefetch" href="/assets/js/43.3f651e5b.js"><link rel="prefetch" href="/assets/js/45.309ead5b.js"><link rel="prefetch" href="/assets/js/46.6f7aeb62.js"><link rel="prefetch" href="/assets/js/47.361ce141.js"><link rel="prefetch" href="/assets/js/48.e6d8a8f3.js"><link rel="prefetch" href="/assets/js/49.33d9f0ac.js"><link rel="prefetch" href="/assets/js/5.51d5e42c.js"><link rel="prefetch" href="/assets/js/50.8b8c70c1.js"><link rel="prefetch" href="/assets/js/51.27f1ce7d.js"><link rel="prefetch" href="/assets/js/52.64320734.js"><link rel="prefetch" href="/assets/js/53.c732a5fa.js"><link rel="prefetch" href="/assets/js/54.541148e9.js"><link rel="prefetch" href="/assets/js/55.36cb41de.js"><link rel="prefetch" href="/assets/js/56.14a7959d.js"><link rel="prefetch" href="/assets/js/57.6a5f2316.js"><link rel="prefetch" href="/assets/js/58.1707cf09.js"><link rel="prefetch" href="/assets/js/59.176b3d1a.js"><link rel="prefetch" href="/assets/js/60.fbfd06af.js"><link rel="prefetch" href="/assets/js/61.c2d4f52a.js"><link rel="prefetch" href="/assets/js/62.0952ea43.js"><link rel="prefetch" href="/assets/js/63.40b1da1b.js"><link rel="prefetch" href="/assets/js/64.a4581053.js"><link rel="prefetch" href="/assets/js/65.72c37f85.js"><link rel="prefetch" href="/assets/js/66.33de2ae0.js"><link rel="prefetch" href="/assets/js/7.aa6f379f.js"><link rel="prefetch" href="/assets/js/8.d5676b08.js"><link rel="prefetch" href="/assets/js/9.e418b8d5.js"><link rel="prefetch" href="/assets/js/vendors~notification.7bcb2342.js">
    <link rel="stylesheet" href="/assets/css/0.styles.05cc7eb5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">云息的面试资料库</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/fedoc/" class="nav-link router-link-active">指南</a></div><div class="nav-item"><a href="http://yunxi.site/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/xiaomuzhu/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/fedoc/" class="nav-link router-link-active">指南</a></div><div class="nav-item"><a href="http://yunxi.site/blog/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/xiaomuzhu/front-end-interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>01-计算机网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/01-计算机网络/CDN和DNS.html" class="sidebar-link">CDN 和 DNS</a></li><li><a href="/fedoc/01-计算机网络/HTTP.html" class="sidebar-link">HTTP</a></li><li><a href="/fedoc/01-计算机网络/前端缓存最佳实践.html" class="sidebar-link">前端缓存最佳实践</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>02-CSS&amp;HTML</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/02-CSS&amp;HTML/CSS 基础.html" class="sidebar-link">CSS 基础</a></li><li><a href="/fedoc/02-CSS&amp;HTML/HTML.html" class="sidebar-link">HTML</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>03-JavaScript</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/03-JavaScript/JS 继承的八种写法.html" class="sidebar-link">JS 继承的八种写法</a></li><li><a href="/fedoc/03-JavaScript/JS异步编程原理.html" class="sidebar-link">JavaScript 异步编程原理</a></li><li><a href="/fedoc/03-JavaScript/JavaScript基础.html" class="sidebar-link">JS 基础</a></li><li><a href="/fedoc/03-JavaScript/异步-手写async_await.html" class="sidebar-link">异步—手写 async_await</a></li><li><a href="/fedoc/03-JavaScript/异步编程专题.html" class="sidebar-link">JS 异步编程：种类和原理</a></li><li><a href="/fedoc/03-JavaScript/手写系列.html" class="sidebar-link">手写系列</a></li><li><a href="/fedoc/03-JavaScript/防抖节流.html" class="sidebar-link">JavaScript防抖、节流以及rAF</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>04-游览器与BOM</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/04-游览器与BOM/Cookie-Session ,JWT认证机制.html" class="sidebar-link">浅谈 Cookie-Session 、Jwt 两种身份认证机制</a></li><li><a href="/fedoc/04-游览器与BOM/Session的概念和安全问题.html" class="sidebar-link">有关 Session 的那些事儿</a></li><li><a href="/fedoc/04-游览器与BOM/V8优化之对象中的快属性与慢属性.html" class="sidebar-link">V8 优化之对象中的快属性与慢属性</a></li><li><a href="/fedoc/04-游览器与BOM/Web Storage 总结.html" class="sidebar-link">Cookie, Session, Web Storage与IndexedDB 总结</a></li><li><a href="/fedoc/04-游览器与BOM/前端安全.html" class="sidebar-link">前端安全</a></li><li><a href="/fedoc/04-游览器与BOM/前端路由的原理.html" class="sidebar-link">前端路由原理及实现</a></li><li><a href="/fedoc/04-游览器与BOM/原生事件.html" class="sidebar-link">原生事件</a></li><li><a href="/fedoc/04-游览器与BOM/跨域.html" class="sidebar-link">跨域</a></li><li><a href="/fedoc/04-游览器与BOM/输入URL1—输入URL和DNS_TCP_HTTP.html" class="sidebar-link">URL1—输入 URL 和游览器</a></li><li><a href="/fedoc/04-游览器与BOM/输入URL2—网络篇.html" class="sidebar-link">URL2—网络篇</a></li><li><a href="/fedoc/04-游览器与BOM/输入URL3—渲染树形成+原理.html" class="sidebar-link">URL3—渲染树形成+原理</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>05-React</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/05-React/React基础.html" class="sidebar-link">React 基础</a></li><li><a href="/fedoc/05-React/React进阶.html" class="sidebar-link">React 进阶</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>06-前端工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/06-前端工程化/Babel 工作原理.html" class="sidebar-link">Babel 是如何转换代码的？</a></li><li><a href="/fedoc/06-前端工程化/Git.html" class="sidebar-link">Git 相关</a></li><li><a href="/fedoc/06-前端工程化/webpack 的工作原理.html" class="sidebar-link">webpack 的工作原理</a></li><li><a href="/fedoc/06-前端工程化/webpack.html" class="sidebar-link">从零搭建 React 开发环境</a></li><li><a href="/fedoc/06-前端工程化/实现一个简易的webpack可选链loader.html" class="sidebar-link">optional-chaining-loader</a></li><li><a href="/fedoc/06-前端工程化/性能优化总结.html" class="sidebar-link">性能优化总结</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>07-前端架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/07-前端架构/Node秒杀系统架构.html" class="active sidebar-link">Node 秒杀系统架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#场景分析" class="sidebar-link">场景分析</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#秒杀类型的业务为什么难做" class="sidebar-link">秒杀类型的业务为什么难做</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#业务规则层面" class="sidebar-link">业务规则层面</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#前端层面" class="sidebar-link">前端层面</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#nginx-层" class="sidebar-link">Nginx 层</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#node-service-层" class="sidebar-link">Node Service 层</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#redis-层" class="sidebar-link">Redis 层</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#kafka-消息队列层" class="sidebar-link">kafka 消息队列层</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#mysql-数据库层" class="sidebar-link">MySQL 数据库层</a></li><li class="sidebar-sub-header"><a href="/fedoc/07-前端架构/Node秒杀系统架构.html#踩过的坑-经验分享" class="sidebar-link">踩过的坑-经验分享</a></li></ul></li><li><a href="/fedoc/07-前端架构/前端监控和埋点方案设计.html" class="sidebar-link">前端监控和前端埋点方案设计</a></li><li><a href="/fedoc/07-前端架构/支付宝架构师眼里的高并发架构.html" class="sidebar-link">支付宝架构师眼里的高并发架构</a></li><li><a href="/fedoc/07-前端架构/架构要考虑什么.html" class="sidebar-link">做架构要考虑什么？</a></li><li><a href="/fedoc/07-前端架构/说说前后端分离.html" class="sidebar-link">说说前后端分离</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>08-Node</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/08-Node/Koa2深度解析.html" class="sidebar-link">Koa2 深度解析</a></li><li><a href="/fedoc/08-Node/Koa2源码和原理浅析.html" class="sidebar-link">Koa源码系列1—手写 Koa 库</a></li><li><a href="/fedoc/08-Node/Node.js多进程底层原理.html" class="sidebar-link">Node.js 多进程底层原理</a></li><li><a href="/fedoc/08-Node/Node.js调试之内存泄漏篇.html" class="sidebar-link">Node.js 调试之内存泄漏篇</a></li><li><a href="/fedoc/08-Node/初探 Node.js 中的事件循环.html" class="sidebar-link">初探 Node.js 中的事件循环</a></li><li><a href="/fedoc/08-Node/操作系统.html" class="sidebar-link">操作系统</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>09-算法和数据结构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/09-算法和数据结构/算法.html" class="sidebar-link">算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>10-知识广度</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fedoc/10-知识广度/200409如何在数据库中存储密码更安全.html" class="sidebar-link">如何在数据库中存储密码更安全？</a></li><li><a href="/fedoc/10-知识广度/200410如何设计一个良好的API接口.html" class="sidebar-link">如何设计一个良好的 API 接口？</a></li><li><a href="/fedoc/10-知识广度/200411二维码扫描登录是什么原理.html" class="sidebar-link">二维码扫描登录是什么原理？</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="node-秒杀系统架构"><a href="#node-秒杀系统架构" aria-hidden="true" class="header-anchor">#</a> Node 秒杀系统架构</h1> <h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p><a href="https://juejin.im/post/5e71164d6fb9a07ce31f05e9#heading-18" target="_blank" rel="noopener noreferrer">原文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>这篇根据抢口罩的实际场景出发，逐层对一个 Node 高并发的系统进行分析，其中 Node 服务层会讲的详细一些，希望你看完，能够有这些收获：</p> <ul><li>Node 生态已经越来越好，一些高性能的 Web 业务场景，是完全可以用 Node 来做的</li> <li>前端应该不止于前端，学习一些服务端的知识，不仅仅单方面的说是为了做一些全栈的系统，更多的是让现有的前端可以去做更多的事情，去尝试更多的可能</li> <li>能够独立去设计一些东西，可以是一个微型全栈的系统，也可以是前端工程化中某个环节的工具</li></ul> <h2 id="场景分析"><a href="#场景分析" aria-hidden="true" class="header-anchor">#</a> 场景分析</h2> <p>想抢个口罩怎么就这么难！接水怪大学之前是湖北的，想给湖北的朋友抢个口罩快递过去，结果显而易见，没有抢到…</p> <p>于是，接水怪痛定思痛，下定决心对口罩秒杀系统架构一探究竟，虽然业界大部分的这种场景应该都是基于 <strong>Java</strong> 实现的，但是怪怪我决定尝试从 Node.js 的方向，配合业界一些成熟的中间件来分析一下整个系统的架构，以及一些常见的问题。</p> <p>关于 Node.js 如何实现高并发的原理，怪怪往期的文章有写哈。😊</p> <p>写之前跟好兄弟丙丙也请教了不少后端侧的东西，对，就是你们熟悉的那个男人，号称自己在互联网苟且偷生的那个<strong>敖丙</strong>！</p> <p>怪怪在这里将前后端一并分享给大家，毕竟 Node 的生态环境日益增强，前端侧能做的东西也越来越多。</p> <p>比如你想在公司自己做一个基于 Node 的<strong>前端发布系统</strong>，也会涉及到 db，缓存，消息中间件这些东西。</p> <p>接下来，让我们请出今天的主角儿，当当当当~~ 它就是低调奢华有内涵的口罩秒杀系统<strong>架构图</strong>，后面的内容会基于这个架构图来摆会儿龙门阵。</p> <p><img src="http://qn-noter.yunxi.site/imagehost/3t5lk.png" alt="image-20200323182849583"></p> <h2 id="秒杀类型的业务为什么难做"><a href="#秒杀类型的业务为什么难做" aria-hidden="true" class="header-anchor">#</a> 秒杀类型的业务为什么难做</h2> <p>秒杀，秒杀，顾名思义就是一个短时间内的高流量操作，是一个天然<strong>高并发</strong>的场景，换句话说，读写冲突十分严重。</p> <p>而通常秒杀类型的业务，价格都比较诱人，这就引发了另外一个薅羊毛的问题，有不少黄牛会在这个时候趁机捞一笔，想必每年春节回家，大家都深有感触吧，还没来得及输完 12306 的高智商验证码，票已经没有了，哦豁~~</p> <p>试想几十万，上百万的流量直接打到 DB？</p> <p>因此，秒杀的核心就在于请求是真实请求的前提下，处理好高并发以及数据库存扣减的问题。</p> <p>接下来，就让我们逐层来看看是怎么做的~</p> <h2 id="业务规则层面"><a href="#业务规则层面" aria-hidden="true" class="header-anchor">#</a> 业务规则层面</h2> <p>针对流量特别大的场景，可以分时分段开展活动，原来统一 10 点抢口罩，现在 6 点，6 点半，7 点，…每隔半个小时进行一次活动，达到流量摊匀的效果。</p> <h2 id="前端层面"><a href="#前端层面" aria-hidden="true" class="header-anchor">#</a> 前端层面</h2> <blockquote><p>APP / H5 / 小程序 / PC</p></blockquote> <h3 id="针对平民老百姓"><a href="#针对平民老百姓" aria-hidden="true" class="header-anchor">#</a> 针对平民老百姓</h3> <p>前端侧会进行一个按钮置灰的操作，当你点击完一次之后，按钮会变灰，防止用户重复提交抢口罩的请求。</p> <h3 id="针对程序员"><a href="#针对程序员" aria-hidden="true" class="header-anchor">#</a> 针对程序员</h3> <p>想必你一定会说，这还不简单？抓个包，写个定时脚本，一到时间，for 循环自动打请求不就好了？</p> <p>我只能说，小伙子，你很优秀，有的场景确实是阔以滴，但是你别慌，接着往下看 ↓↓↓</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc0b78eca34?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>别着急，刚刚就是让你皮一下，哦豁~</p> <p>针对上面这种情况，后端 controller 层会进行处理，简单来说就是对同一个用户抢口罩的请求进行校验，对于同一个用户在短时间内发送的大量请求进行次数限制，以及请求去重处理~</p> <p>但怪怪我咨询了风控的朋友，现在企业中大部分场景，后端是不做这个特殊处理，而是让<strong>风控团队</strong>来处理，下面所谓黑客的部分会稍微细说一下。</p> <p>道高一尺，魔高一丈，接下来请出我们的终极大魔王，高端 Hacker！！</p> <h3 id="针对更加高端的-hacker-们"><a href="#针对更加高端的-hacker-们" aria-hidden="true" class="header-anchor">#</a> 针对更加高端的 Hacker 们</h3> <p>比如一些高端 Hacker，控制了 30w 个 Dorking，也就是这些人手上有 30w 的 uid，如果他们同时发动手上 30w 的 Dorking 来抢口罩，咋办？</p> <p>此时，再一次陷入了尴尬~ 哦豁~~</p> <blockquote><p>这个问题，怪怪我咨询了安全、以及风控的朋友，简单跟大家分享一下</p></blockquote> <p>首先，安全针对秒杀，没做啥特殊的处理。</p> <p>一般来讲，秒杀类工作主要在风控这边，对于那种利用机器或者脚本疯狂刷新的，QPS 异常高的，换句话说就是短时间内流量异常高滴的用户，会直接给他弹一个<strong>滑块</strong>（滑动验证，应该大家都遇到过这种情况），这样可以大大提高那些刷请求批量操作的成本，甚至能够遏制他们的行为。</p> <p>同时风控也会根据一系列的规则（通过这些规则来判定这个 uid 也就是这个用户是否符合要求，不要问我具体规则，怪怪我还想继续写文章，不想进去~~），对于那些不符合平台下单要求的 Dorking ，直接进行请求拦截，甚至有的会加入黑名单，直接取消掉这个用户的相关权限。</p> <p>写到这里，我想说，风控、安全团队，你们还是有点东西！！</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc0e6441ca6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <h2 id="nginx-层"><a href="#nginx-层" aria-hidden="true" class="header-anchor">#</a> Nginx 层</h2> <blockquote><p>实际上真正的企业架构中，在 Nginx 的上面一层还会有一层 lvs ，这里不展开讲，简单解释就是能够在网络第 4 层对 Nginx 服务的 ip 进行负载均衡</p></blockquote> <p>虽然上面我们拦截了恶意请求，减少了部分流量，但秒杀真实的用户也超多的啊，你想想这次有多少人在抢口罩！</p> <p>所以我们我们还是要搞负载均衡~~</p> <p>我们先简单解释一下集群跟负载均衡是个什么玩意儿，哦豁~</p> <p><strong>集群</strong>嘛，简单来讲就是我们不是有秒杀的 Node 服务嘛，那一台机器是不是有可能会挂掉，流量太大，单台机器根本扛不住，咋办？</p> <p>加机器呗，一台会被打挂，那我们多搞几台，不就变强啦？俗话说，1 根牙签一碰就断，10 根牙签…… 咦，好像也是一碰就断，hhhh，哦豁~</p> <p>那<strong>负载均衡</strong>是嘛玩意儿嘛？刚上面不是说了集群就是加机器嘛，那现在机器虽然变多了，来了一个请求，具体派哪个机器去处理，是不是得有一套规则嘛，并且这套规则要让请求分发的比较合理，不然就失去了集群的意义了撒~</p> <p>Nginx 层下面是基于 Node 的 service 层，也就是业务逻辑会在这里进行处理，实际上 Nginx 在这里主要做了两件事：</p> <ul><li>对于前端打过来的真实的抢口罩请求，在 Nginx 这里进行请求的分发，打到 Node 集群的某一个机器上</li> <li>健康检测，Node 集群的机器同样有可能挂掉，所以会利用 Nginx 进行检测，发现挂了的机器，会干掉重启，保证集群的高可用。检测有两种机制，被动检测跟主动检测，不展开说，后面会出一篇 Nginx 原理与实战的文章，像跨域啊，项目部署啊，自己搞个代理啥的啊，都可以用 Nginx 来搞，哦豁~</li></ul> <h2 id="node-service-层"><a href="#node-service-层" aria-hidden="true" class="header-anchor">#</a> Node Service 层</h2> <blockquote><p>这一层我会说的细一些，让我们挨个来摆下龙门阵吧~~</p></blockquote> <h4 id="首先，为什么选择-node-来做-service-层"><a href="#首先，为什么选择-node-来做-service-层" aria-hidden="true" class="header-anchor">#</a> 首先，为什么选择 Node 来做 service 层</h4> <p>想必大家都知道服务模型是经历了 4 个阶段滴，同步、复制进程、多线程、以及事件驱动。</p> <p>不清楚的同学需要补补作业啦~</p> <p>多线程目前业界以 Java 为首，性能啥的就不说了，各种<strong>双十一</strong>已经证明这位兄台是个狠人。</p> <p>但是，怪怪我觉得，虽然多线程之间可以共享数据，内存可以充分利用，并且利用线程池可以较少创建和销毁线程，节省开销。但是，还是存在一些问题，比如：</p> <ul><li>操作系统在切换线程的时候，同样需要切换线程上下文，如果线程数量太多，切换线程会花费大量时间</li> <li>多线程之间的数据一致性问题，各种加锁的神仙操作，也容易出问题</li></ul> <p>那能不能让我们人见人爱滴小阔爱，Node 小朋友，来尝试搞一下？</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc0edf7604a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>Node 是基于<strong>事件驱动模型</strong>滴，相信前端同学都知道事件驱动，后端同学可能有点懵，但是作为后端同学，Node 你没搞过，Nginx 你总用过哈，Node 跟 Nginx 都是基于事件驱动模型滴~</p> <p>并且，Node 是单线程，采用单线程可以避免不必要的内存开销，以及上下文切换。</p> <p>跟多线程 Java 比起来，好像 Node 也有自己的优势呢~</p> <blockquote><p>我知道，已经有不少同学迫不及待要接着问我了，尤其是后端同学心里肯定在想，你 TM 逗我呢，你一个单线程还能来搞高并发，多核 CPU 怎么利用？</p></blockquote> <p>毕竟隔行如隔山，后端大佬对我们 Node 有误解，也是情有可原，就跟很多前端觉得 Java 用<strong>类型检测</strong>是很麻烦的，不如我们 JS 灵活，是一个道理~</p> <p>如果我们 Node 解决了多核 CPU 的资源利用问题，再加上 Node <strong>异步非阻塞</strong>的特性，带来的性能上的提升应该是很不错滴，并且也没有复杂的多线程啊，加锁这一类心累的问题。</p> <p>关于 Node 单线程如何实现高并发，可以查看往期文章哦 💖</p> <h4 id="node-master-worker-模式"><a href="#node-master-worker-模式" aria-hidden="true" class="header-anchor">#</a> Node Master-Worker 模式</h4> <p>我们顺着架构图，一步步来分析~</p> <p><img src="http://qn-noter.yunxi.site/imagehost/2pdvk.png-style1" alt="image-20200323182922628"></p> <p>先看这里，说好的单进程，单线程呢，这是个什么鬼？</p> <p>别着急，这是 Node 进程模型中著名滴 <strong>Master-Worker</strong> 模式哦~</p> <p>还不是因为单线程，无法利用多核 CPU 嘛，我们的小阔爱 Node 提供了 child_process 模块，或者说 cluster 模块也行，可以利用 child_process 模块直接创建子进程。</p> <p>说到这里， HTML5 提出的 <strong>Web Worker</strong> ，方式大同小异，解决了 JavaScript 主线程与 UI 渲染线程互斥，所引发的长时间执行 JavaScript 导致 UI 停顿不响应的问题。</p> <blockquote><p>cluster 模块：实际上就是 child_process 模块跟其它模块的组合
另外申明一点：fork 线程开销是比较大的，要谨慎使用，并且我们 fork 进程是为了利用 CPU 资源，跟高并发没啥大关系</p></blockquote> <p>这样看来，多核 CPU 的资源利用问题，好像得到了解决，虽然看起来方式稍显粗暴~</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc11eb271ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>我们再次回归到上面的主、子进程的架构图，接着谈谈主进程与子进程<strong>通信</strong>的问题，现在一个口罩秒杀请求过来了，Node 主进程，子进程这里是怎么进行处理的呢？</p> <h4 id="主-子进程通信"><a href="#主-子进程通信" aria-hidden="true" class="header-anchor">#</a> 主-子进程通信</h4> <p>想必大家都知道 <strong>IPC</strong>，也就是进程间通信，首先要申明的是实现 IPC 的方式不止一种，比如共享内存啊、信号量啊等等~~</p> <p>而 Node 是基于<strong>管道</strong>技术实现滴，管道是啥？</p> <p>在 Node 中管道只是属于抽象层面的一个叫法而已，具体的实现都扔给一个叫 libuv 的家伙去搞啦~之前的文章有讲到 Node 的 3 层架构，libuv 是在最下层滴哦，并且大家都知道 Node 可以跨平台嘛，libuv 会针对不同的平台，采用不同的方式实现进程间的通信。</p> <p><img src="http://qn-noter.yunxi.site/imagehost/ouloo.png-style1" alt="image-20200323182932428"></p> <p>ok，我们上面大致说完了理论部分，是不是要实战一把了？</p> <h3 id="客户端请求代理转发"><a href="#客户端请求代理转发" aria-hidden="true" class="header-anchor">#</a> 客户端请求代理转发</h3> <p><img src="http://qn-noter.yunxi.site/imagehost/w9t45.png-style1" alt="image-20200323182941023"></p> <p>一把大叉叉什么鬼？说明通过代理请求转发这种方式是不太友好滴~</p> <p>那我们具体分析一下，为什么不友好，怎么改进？</p> <p>首先我们需要明确一点，操作系统有一个叫<strong>文件描述符</strong>的东西，这个涉及到操作系统<strong>内核</strong>的一些小知识点，并且操作系统的文件描述符是有限的，维护起来也是需要成本滴，因此不能铺张浪费~</p> <p>那我们分析一下上面的流程，这些口罩请求打到主进程上面，主进程对这些请求进行代理，转发到不同端口的子进程上，看起来一切都那么美好~</p> <p>并且在主进程这里，我们还可以继续进行一层负载均衡，让每个子进程的任务更加合理。</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc14917b201?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>but，but，接下来是重点！！</p> <p>前面我们说啦，操作系统的文件描述符不能铺张浪费，我们来看看这个代理的方式，有没有浪费~</p> <p>首先，需要明确一点。进程每收到一个连接，就会用到一个文件操作符，所以呢？来，怪怪给你整个当字开头的排比句！</p> <p>当客户端连接到主进程的时候，用掉一个操作符~</p> <p>当主进程连接到子进程，又用掉一个~</p> <p>所以嘛，从数量上来看，代理方案浪费掉了整整一倍，这好像不太科学，囊个搞内？</p> <blockquote><p>怪怪那儿的方言，“囊个搞”，就是怎么办的意思咯~~</p></blockquote> <p>魔高一尺，道高一丈~</p> <h4 id="句柄传递-去除代理"><a href="#句柄传递-去除代理" aria-hidden="true" class="header-anchor">#</a> 句柄传递-去除代理</h4> <p>Node 在 v0.5.9 引入了进程间发送句柄的机制，简单解释一下，句柄实际上就是一种可以用来标识资源的引用。</p> <p>通过<strong>句柄传递</strong>，我们就可以去掉代理这种方案。使主进程收到客户端的请求之后，将这个请求直接发送给工作进程，而不是重新与子进程之间建立新的连接来转发数据。</p> <p>但实际上这一块还涉及到很多知识点，比如句柄的发送与还原啊，端口的共同监听啊等系列问题。</p> <blockquote><p>这一块的具体实现，可以参考 《深入浅出 Node.js 》9.2.3 句柄传递</p></blockquote> <p>最终，通过句柄传递就可以得到我们想要的效果，即不经过代理，子进程直接响应了客户端的请求。</p> <p><img src="http://qn-noter.yunxi.site/imagehost/azx5q.png-style1" alt="image-20200323182954167"></p> <p>怪怪我也去研究了一下 Egg.js 在多进程模型和进程间通信这块是怎么做滴，大体架构思路跟上面差不多，不同的点在于， Egg.js 搞了一个叫 Agent 的东西。</p> <p>对于一些后台运行的重复逻辑，Egg.js 将它们放到了一个单独的进程上去执行，这个进程就叫 <strong>Agent Worker</strong>，简称 Agent，专门用来处理一些公共事务，具体细节可以参考 Egg.js 官网。</p> <h4 id="子进程服务高可用问题"><a href="#子进程服务高可用问题" aria-hidden="true" class="header-anchor">#</a> 子进程服务高可用问题</h4> <p>毕竟是秒杀服务，fork 的子进程是可能挂滴，所以我们需要一种机制来保证子进程的高可用。</p> <p>我知道，你肯定会说，挂了，重启一个继续提供服务不就好了？</p> <p>对，你说的没错，我们就先来搞定<strong>重启</strong>这一趴~</p> <p>假如现在某个子进程发生异常啦，哦豁~</p> <p>那么，此时这个子进程会立即停止接受新的请求连接，直到所有连接断开，当这个子进程退出的时候主进程会监听到一个 exit() 事件，然后主进程重启一个子进程来进行补偿。</p> <p>也就是这样一个流程。</p> <p><img src="http://qn-noter.yunxi.site/imagehost/pm5mc.png-style1" alt="image-20200323183008630"></p> <p>小伙子，你很不错，但是极端情况我们是不是也要考虑一下子？</p> <blockquote><p>假如有一天，出现极端情况，你所有的女朋友一夜之间都要跟你分手，是不是开始慌了？（坏笑~~）</p></blockquote> <p>如果所有的子进程同时异常了，按照我们上面的处理方式，所有的子进程都停止接收新的请求，整个服务岂不是就会出现瞬时瘫痪的现象了？大部分的新请求就会白白丢掉，想想如果是双十一，损失得有多大，哦豁~</p> <p>既然如此，我们就来改进一下。</p> <p>有的小伙伴可能会说，我知道怎么搞了！！！</p> <p>既然不能一直等待着，那就直接<strong>强行 kill</strong> 干掉这个进程，然后立马重启一个！！</p> <p>小伙子，你有点激动，不过可以理解，毕竟能想到这里，你还是有点东西~~ 不过可以更加全面一点</p> <p>强行 kill 掉，会导致已连接的用户直接中断，那用户也就自然离开啦~ 哦豁~</p> <p>所以，总结起来我们要解决的就是，如何在不丢失现有用户请求的基础上，重启新的子进程，从而保证业务跟系统的双重高可用！！！</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc169e516bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>忽然灵光一现，我们可以这样搞撒~</p> <p>上面分析到主进程要等到子进程退出的时候，才会去重启新的子进程，这就有点意思啦！！ 同志，不要等到分手了再去反思自己哪里做的不对！！！ ，只要女朋友一生气，即使响应，立马认错，没毛病~~~</p> <p>因此，我们可以在子进程刚出异常的时候，就给主进程发一个<strong>自杀信号</strong>，主进程收到信号后，立即创建新的子进程，这样上面的问题完美解决！！</p> <p>从此跟女朋友过上了幸福美好滴生活~</p> <h4 id="node-集群"><a href="#node-集群" aria-hidden="true" class="header-anchor">#</a> Node 集群</h4> <p>搞定了上述秒杀服务 Node 主进程，子进程高可用的问题之后，我们就可以搭建 Node 集群了，进一步提高整个系统的高可用，Node 集群的负载均衡，文章一开始的 Nginx 层已经讲过啦~</p> <p>至于集群做多大，用多少台机器，这些需要根据具体的业务场景来决策。并且一般大型的活动上线之前，企业内部会进行几轮压测，简单来讲，就是模拟用户高并发的流量请求，然后看一下小伙子你搞的这个系统抗不扛得住，靠不靠谱~</p> <p>但真正的<strong>压测</strong>，远比我说的要复杂，比如压测中某个环节出了问题，扛不住啦，是直接重启机器，还是扩容，又或者是降低处理等等，这都是需要综合考虑滴~</p> <p>当然，最终的目的也是在保证服务高可用的前提下能给企业节约成本，毕竟加机器扩容是需要成本滴~</p> <p>同样的需求，别人要 5 台机器，你只要 4 台就能搞定，小伙子，那你就真的有点东西啦，升职加薪指日可待！！~</p> <h4 id="数据一致性"><a href="#数据一致性" aria-hidden="true" class="header-anchor">#</a> 数据一致性</h4> <p>搞定了上面 Node 服务的各个环节之后，还有一个很重要的问题要解决，我丢！！！ 咋还有问题~~</p> <p>首先，明确一个知识点，Node 多个进程之间是不允许共享数据滴~</p> <p>这就是最后一个非常重要的问题，<strong>数据共享</strong>。</p> <p>实际业务中，就拿我们今天的口罩系统来说，库存量就是一个典型数据共享的场景，会有多个进程需要知道现在还有多少库存，不解决好这个问题，就很有可能发生口罩超卖的问题。</p> <blockquote><p>超卖，简单来讲就是，怪怪家一共有 200 只口罩等待出售，然后怪怪我在某平台上发起了一个秒杀抢口罩的活动，由于平台的数据没处理好，怪怪我在后台惊喜的收到了 500 个订单，超出了 300 个订单，这就是超卖现象啦~</p></blockquote> <p>那这个问题，我们应该如何避免呢，怪怪我有点心累，买个口罩怎么这么复杂！</p> <p>既然 Node 本身不支持数据共享，ok，那我们就用三方的嘛，比如今天的第二个主角~ 当当当当~~ 它就是一位名叫 Redis 的神秘女子，身穿红色外套，看着还有点内敛~</p> <p><img src="http://qn-noter.yunxi.site/imagehost/ie0bx.png-style1" alt="image-20200323183029552"></p> <p>至于 Redis 这里如何保持数据一致，放到下面 Redis 的部分一起说。</p> <h2 id="redis-层"><a href="#redis-层" aria-hidden="true" class="header-anchor">#</a> Redis 层</h2> <p>我们使用 Redis 解决上述遗留的 Node 进程间数据不能共享的问题。</p> <p>解决问题之前，先简单介绍一下 Redis ，毕竟，都不认识，怎么开始恋爱？</p> <blockquote><p>Redis 还是有很多知识点滴，具体可查看 Redis 官网</p></blockquote> <p>相信大家在大学的时候都接触过 SQL Server ，相信你也曾经因为 SQL Server 那诡异的环境曾头痛~</p> <p>但大部分学校，应该都是没有 Redis 这门课滴，如果有，怪怪我只能说，朋友，你的学校有点东西！！</p> <p>步入正题，Redis 是一个在内存中进行数据结构存储的系统，可以用作数据库、缓存和消息中间件，是 key-value 的形式来进行数据的读写。简单理解就是，我们可以利用 Redis 加缓存减轻 db 的压力，提升用户读写的速度。</p> <p>大家要明确的是，<strong>秒杀的本质就是对库存的抢夺</strong>，如果每个从上层 Node 服务打过来的请求，都直接去 db 进行处理，</p> <p>抛开最大的性能问题先不说，你不觉得这样好繁琐，对开发人员以及后期的维护都很不友好嘛？</p> <h4 id="那咋办"><a href="#那咋办" aria-hidden="true" class="header-anchor">#</a> 那咋办</h4> <p>上面已经说啦，直接搞到 MySQL 扛不住，你可以找她闺蜜 Redis 嘛，写一个定时脚本，在秒杀还<strong>未开始</strong>之前，就把当前口罩的库存数量写入 Redis，让 Node 服务的请求从 Redis 这里拿数据进行处理，然后异步的往 kafka 消息队列里面写入抢到口罩用户的订单信息（这一块具体的放到后面 kafka 消息队列部分分析）。</p> <p>那这里就关联上了我们前面提到的问题，数据一致性问题，如何保证 Node 服务从你 Redis 拿到的库存量是没有问题滴？</p> <p>如果直接按正常的逻辑去写，抢到口罩，Redis 中库存 count -1，这种方式看起来是没有问题滴，但是我们来思考这样一个场景。</p> <p>比如仓库里面还有最后 1 个口罩，现在光头强发了一个请求过来，读了一下 Redis 的数据，count 为 1，然后点击下单，count - 1 。但如果此时 count 正在执行 -1 的操作的时候（此时 count 依然是 1 ），熊大哥哥一看这形式不对，也开始抢口罩，一个查库存量的请求再一次打了过来，发现 Redis 中库存量仍然为 1 ，然后点击下单。</p> <p>按上述的流程，就会发生文章一开头提到的超卖现象，1 只口罩，你给我下了两个单？！！！</p> <h4 id="这又咋办"><a href="#这又咋办" aria-hidden="true" class="header-anchor">#</a> 这又咋办</h4> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc1884b9421?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>我们可以加<strong>事务</strong>嘛！！</p> <p>事务可以一次执行多个命令，并且有两个很重要的特性~</p> <ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li> <li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li></ul> <p>这里直接引用 Redis 的官方示例来解决超卖问题，官方示例讲的是执行 +1 的操作，我们这里只需要修改成 -1 就 ok。具体可参考官方文档。</p> <p><img src="http://qn-noter.yunxi.site/imagehost/21zyj.png" alt="image-20200323183046027"></p> <p>这样一来，Node 数据共享，库存减叩的问题就搞定了，Redis 小姐姐，你有点东西！！~</p> <p>那如果单台 Redis 扛不住怎么办，我们可以对 Redis 进行集群嘛，主从同步这一系列的操作，然后再搞点<strong>哨兵</strong>，<strong>持久化</strong>也搞上，那你这个秒杀直接无敌！！！</p> <p>后续有时间，会写一个基于 Node.js 的 Redis 实战与原理剖析 😁，之前怪怪写过一个<strong>可视化页面搭建</strong>系统，其中各个模块在后台进行渲染的时候，为了提高渲染速度，就用到了 Redis 进行高速缓存。</p> <p>缓存这一趴告一段落，下面接着说说消息队列~</p> <h2 id="kafka-消息队列层"><a href="#kafka-消息队列层" aria-hidden="true" class="header-anchor">#</a> kafka 消息队列层</h2> <p>如果将订单数据一次性全部写入 db，性能不好，出现峰值的时候，很容易导致服务器宕机，所以会先往消息队列里面存一下，做流量的削峰。当然消息队列不仅仅是起到了这个作用，像什么应用的解耦，也可以基于 kafka 来做一层封装处理。</p> <p>先简单说一下消息队列，不光秒杀，其它场景的使用大同小异。</p> <p>kafka 消息队列就是基于<strong>生产者-消设计模式</strong>滴，按具体场景与规则，针对上层请求让生产者往队列的末尾添加数据，让多个消费者从队列里面依次读取数据然后自行处理。</p> <p>结合到我们的秒杀场景就是，对订单进行分组存储管理，然后让多个消费者来进行消费，也就是把订单信息写入 db。</p> <p>这里附上一张经典的消息队列的图，有兴趣的小伙伴可以深入去了解 kafka，还是有点东西。</p> <h4 id="消息积压"><a href="#消息积压" aria-hidden="true" class="header-anchor">#</a> 消息积压</h4> <p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p> <p>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。
新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。
然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。
接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。
等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</p> <h4 id="如何设计"><a href="#如何设计" aria-hidden="true" class="header-anchor">#</a> 如何设计</h4> <p>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量。</p> <p>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。</p> <p><img src="http://qn-noter.yunxi.site/imagehost/5s50l.png" alt="image-20200323183104331"></p> <h2 id="mysql-数据库层"><a href="#mysql-数据库层" aria-hidden="true" class="header-anchor">#</a> MySQL 数据库层</h2> <p>数据库这块不多说，数据存储的地方，最终的订单信息会写到 MySQL 中进行持久化存储。</p> <p>简单模拟这个系统的话，表结构就搞到最简化就行。</p> <div class="language-sql extra-class"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">`</span>seckill<span class="token punctuation">`</span><span class="token punctuation">(</span>
   <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token keyword">UNSIGNED</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
   <span class="token punctuation">`</span><span class="token keyword">date</span><span class="token punctuation">`</span> <span class="token keyword">TIMESTAMP</span><span class="token punctuation">,</span>
   <span class="token punctuation">`</span>stock<span class="token punctuation">`</span> <span class="token keyword">INT</span> <span class="token keyword">UNSIGNED</span><span class="token punctuation">,</span>
   <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span> <span class="token punctuation">`</span>id<span class="token punctuation">`</span> <span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>
复制代码
</code></pre></div><p>深入学习 MySQL，还是有些东西滴，查询优化啊，索引怎么用啊，底层数据结构啊，怎么去设计表啊等等一些列问题都可以去探究~</p> <blockquote><p>相信前段时间搞的沸沸扬扬滴删库跑路事件，大家也都听说了~~</p></blockquote> <p>顺便提一嘴，很多小伙伴说，我想搞一下前端工程化，我想搞几个减少开发流程的系统，我想…</p> <p>就举个很简单的例子，企业都有线下、预发、线上这一套环境，你想开发一款 host 切换工具来切各个不同的环境，两种方式：</p> <ul><li>直接基于 <strong>Electron</strong> 写一个本地 host 文件（etc/hosts）读写的工具，看似也没什么毛病</li> <li>但既然是整个公司用，那思维就不要太局限啦，如果仅仅开发一个本地 host 文件读写的工具，那没什么意思，大家直接用开源的不就好了，还节省成本，不用开发。</li> <li>做成可配置滴，公共的 host 配置文件存到 db，并且支持本地自定义配置，这就很棒啊，全公司统一。假如哪天预发的机器 ip 变了，那么只用去 host 工具管理后台更新一下，全公司所有的小伙伴就可以一键更新啊，是不是很爽？？</li></ul> <p>怪怪之前是维护我们公司的这个 host 小工具滴，后面计划自己写一套<strong>开源</strong>出来。</p> <p>什么，这么个破玩意儿你还要开源？</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc197acdc2c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>举上面的例子，就是想说，Node 生态越来越好，我们前端能做的事情也越来越多，我们有义务去接触更多的东西，寻找更多前端的突破口~</p> <p>狼叔那一篇在 cnode 社区置顶的文章，就写的非常赞！！~~~</p> <h2 id="踩过的坑-经验分享"><a href="#踩过的坑-经验分享" aria-hidden="true" class="header-anchor">#</a> 踩过的坑-经验分享</h2> <p>能够看到这里，说明你有点东西，整个系统的各个层都讲了一下，我估计现在让你自己来搞一个秒杀系统，也问题不大了~</p> <p>怪怪我基于文章开头的架构图，自己搞了一个低配版的 Node 秒杀系统，在这里把踩过的一些小坑跟大家分享一下，毕竟踩过的坑，不希望大家踩第二次！</p> <p>首先，如果大家自己在本地搞这个系统，可能乍一看，又有 Node，又有 Nginx，又有 Redis ，又有 kafka，而且管理 kafka 还要用 zookeeper，感觉这也太麻烦了，可能看到这个<strong>环境搭建</strong>都望而却步了~。</p> <p>淡定，淡定！！</p> <p><img src="https://user-gold-cdn.xitu.io/2020/3/17/170e5dc1a968c183?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p> <p>我们可以用 <strong>docker</strong> 来搞嘛，这样就很轻量并且很方便管理，没用过的小伙伴强烈建议去学习一下~
使用 docker 来搞，上面说的几个环境，一个配置文件就搞定，简单示意一下：</p> <div class="language-plain extra-class"><pre class="language-text"><code>services:
  zk:
    image: wurstmeister/zookeeper
    ports:
      - &quot;2181:2181&quot;
  kfk:
    image: wurstmeister/kafka
    ports:
      - &quot;9092:9092&quot;
    environment:
      KAFKA_ADVERTISED_HOST_NAME: 172.17.36.250
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
    volumes:
      - ./docker.sock:/var/run/docker.sock
  redis:
    image: redis
    ports:
      - &quot;6379:6379&quot;
  mysql:
    image: mysql
    ports:
      - &quot;3306:3306&quot;
    environment:
      MYSQL_ROOT_PASSWORD: 'password'
复制代码
</code></pre></div><h4 id="遇到过坑的小总结"><a href="#遇到过坑的小总结" aria-hidden="true" class="header-anchor">#</a> 遇到过坑的小总结</h4> <ul><li><p>用 docker 搭建环境，避免自己去装那些不必要的环境，比如 MySQL。</p></li> <li><p>使用 Docker Compose 定义和运行多容器的 Docker 应用程序，便于容器的集中配置管理。</p></li> <li><p>删除 Docker 容器，容器里面的数据还是会在你物理机上面，除非你手动去清理。</p></li> <li><p>kafka-node 这个 npm 包，最新的版本用法相比老版本有一些更新，比如老版本创建一个 kafkaClient 的写法是 new kafka.Client(); 但新版本现在已经是 new kafka.KafkaClient(); 这种写法了</p></li> <li><p>kafka 的 docker 镜像，官方提供的 docker-compose 示例未指定端口映射关系，需要自行处理一下映射关系</p></li> <li><div class="language- extra-class"><pre class="language-text"><code>Egg.js 首次在连接 MySQL 的 docker 容器的时候，会出现 Client does not support authentication protocol requested by server; 的异常，修改一下密码就 ok。

ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'your_new_password';
FLUSH PRIVILEGES;
复制代码
</code></pre></div></li></ul> <h3 id="被后端朋友灵魂-3-问的小分享"><a href="#被后端朋友灵魂-3-问的小分享" aria-hidden="true" class="header-anchor">#</a> 被后端朋友灵魂 3 问的小分享</h3> <h5 id="如果是一家很小的公司，由于资金问题机器不够用来集群怎么办"><a href="#如果是一家很小的公司，由于资金问题机器不够用来集群怎么办" aria-hidden="true" class="header-anchor">#</a> 如果是一家很小的公司，由于资金问题机器不够用来集群怎么办</h5> <p>万一机器不够，只能放弃部分请求，原则上还是要已保护系统为核心，不然所有的请求都失败，就更不理想</p> <hr> <h5 id="kafka-队列这边如果发生异常处理失败怎么反馈给用户"><a href="#kafka-队列这边如果发生异常处理失败怎么反馈给用户" aria-hidden="true" class="header-anchor">#</a> kafka 队列这边如果发生异常处理失败怎么反馈给用户</h5> <p>那就给用户及时反馈说下单失败，让用户重试，都已经抢到口罩了，重新下个单应该问题不大的，再者，这是少数情况~</p> <hr> <h5 id="抢到口罩之后未及时支付或取消这笔订单，如何对剩余库存做及时的处理呢"><a href="#抢到口罩之后未及时支付或取消这笔订单，如何对剩余库存做及时的处理呢" aria-hidden="true" class="header-anchor">#</a> 抢到口罩之后未及时支付或取消这笔订单，如何对剩余库存做及时的处理呢</h5> <p>首先，抢到口罩之后，支付界面会有一个支付的时间提醒，例如，超过 20 分钟未支出，这笔订单将被取消。关联到数据库里就会有一个未支出的状态。如果超过时间，库存将会重新恢复。</p> <p>前端侧也会给到用户对应的提示，比如 20 分钟之后再试试看，说不定又有口罩了哟~</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/xiaomuzhu/front-end-interview/edit/master/fedoc/07-前端架构/Node秒杀系统架构.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/fedoc/06-前端工程化/性能优化总结.html" class="prev">
          性能优化总结
        </a></span> <span class="next"><a href="/fedoc/07-前端架构/前端监控和埋点方案设计.html">
          前端监控和前端埋点方案设计
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.dcf74adf.js" defer></script><script src="/assets/js/3.d459fbac.js" defer></script><script src="/assets/js/44.7e0185a5.js" defer></script><script src="/assets/js/6.da654ace.js" defer></script>
  </body>
</html>
