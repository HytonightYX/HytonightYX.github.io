(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{233:function(t,e,a){"use strict";a.r(e);var v=a(4),_=Object(v.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"react-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-基础","aria-hidden":"true"}},[t._v("#")]),t._v(" React 基础")]),t._v(" "),a("h2",{attrs:{id:"react-最新的生命周期是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-最新的生命周期是怎样的","aria-hidden":"true"}},[t._v("#")]),t._v(" React 最新的生命周期是怎样的?")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5b6f1800f265da282d45a79a#heading-0",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"挂载阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#挂载阶段","aria-hidden":"true"}},[t._v("#")]),t._v(" 挂载阶段")]),t._v(" "),a("ul",[a("li",[t._v("constructor")]),t._v(" "),a("li",[t._v("getDerivedStateFromProps")]),t._v(" "),a("li",[t._v("UNSAVE_componentWillMount 组件即将被装载、渲染到页面上")]),t._v(" "),a("li",[t._v("render 组件在这里生成虚拟的"),a("code",[t._v("DOM")]),t._v("节点")]),t._v(" "),a("li",[t._v("componentDidMount 组件真正在被装载之后")])]),t._v(" "),a("h3",{attrs:{id:"更新阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新阶段","aria-hidden":"true"}},[t._v("#")]),t._v(" 更新阶段")]),t._v(" "),a("p",[t._v("更新阶段，当组件的 props 改变了，或组件内部调用了 setState 或者 forceUpdate 发生，会发生多次")]),t._v(" "),a("ul",[a("li",[t._v("UNSAFE_componentWillReceiveProps 组件将要接收到属性的时候调用")]),t._v(" "),a("li",[t._v("getDerivedStateFromProps")]),t._v(" "),a("li",[t._v("shouldComponentUpdate")]),t._v(" "),a("li",[t._v("UNSAFE_componentWillUpdate 组件即将更新不能修改属性和状态")]),t._v(" "),a("li",[t._v("render")]),t._v(" "),a("li",[t._v("getSnapshotBeforeUpdate")]),t._v(" "),a("li",[t._v("componentDidUpdate")])]),t._v(" "),a("h3",{attrs:{id:"卸载阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#卸载阶段","aria-hidden":"true"}},[t._v("#")]),t._v(" 卸载阶段")]),t._v(" "),a("ul",[a("li",[t._v("componentWillUnmount")])]),t._v(" "),a("p",[t._v("当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的 DOM 元素等垃圾清理工作")]),t._v(" "),a("p",[t._v("注意不要在这个函数里去调用 setState，因为组件不会重新渲染了")]),t._v(" "),a("h2",{attrs:{id:"ajax-应该放在哪个生命周期中？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ajax-应该放在哪个生命周期中？","aria-hidden":"true"}},[t._v("#")]),t._v(" ajax 应该放在哪个生命周期中？")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("React")]),t._v(" 下一代调和算法 "),a("code",[t._v("Fiber")]),t._v(" 会通过开始或停止渲染的方式优化应用性能，其会影响到 "),a("code",[t._v("componentWillMount")]),t._v(" 的触发次数。对于 "),a("code",[t._v("componentWillMount")]),t._v(" 这个生命周期函数的调用次数会变得不确定，"),a("code",[t._v("React")]),t._v(" 可能会多次频繁调用 "),a("code",[t._v("componentWillMount")]),t._v("。如果我们将 "),a("code",[t._v("AJAX")]),t._v(" 请求放到 "),a("code",[t._v("componentWillMount")]),t._v(" 函数中，那么可能会被触发多次，自然也就不是好的选择。")]),t._v(" "),a("li",[t._v("如果我们将"),a("code",[t._v("AJAX")]),t._v(" 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了"),a("code",[t._v("setState")]),t._v("函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 "),a("code",[t._v("componentDidMount")]),t._v(" 函数中进行 "),a("code",[t._v("AJAX")]),t._v(" 请求则能有效避免这个问题")])]),t._v(" "),a("h2",{attrs:{id:"diff-算法做了哪些优化？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法做了哪些优化？","aria-hidden":"true"}},[t._v("#")]),t._v(" diff 算法做了哪些优化？")]),t._v(" "),a("ul",[a("li",[t._v("把树形结构按照层级分解，只比较同级元素。")]),t._v(" "),a("li",[t._v("给列表结构的每个单元添加唯一的"),a("code",[t._v("key")]),t._v("属性，方便比较。")]),t._v(" "),a("li",[a("code",[t._v("React")]),t._v(" 只会匹配相同 tag 的 "),a("code",[t._v("component")]),t._v("（这里面的"),a("code",[t._v("class")]),t._v("指的是组件的名字）")]),t._v(" "),a("li",[t._v("合并操作，调用 "),a("code",[t._v("component")]),t._v(" 的 "),a("code",[t._v("setState")]),t._v(" 方法的时候, "),a("code",[t._v("React")]),t._v(" 将其标记为 - "),a("code",[t._v("dirty")]),t._v(".到每一个事件循环结束, "),a("code",[t._v("React")]),t._v(" 检查所有标记 "),a("code",[t._v("dirty")]),t._v("的 "),a("code",[t._v("component")]),t._v("重新绘制.")]),t._v(" "),a("li",[t._v("选择性子树渲染。开发人员可以重写"),a("code",[t._v("shouldComponentUpdate")]),t._v("提高"),a("code",[t._v("diff")]),t._v("的性能")])]),t._v(" "),a("h2",{attrs:{id:"shouldcomponentupdate-如何配合性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#shouldcomponentupdate-如何配合性能优化","aria-hidden":"true"}},[t._v("#")]),t._v(" shouldComponentUpdate 如何配合性能优化")]),t._v(" "),a("p",[a("strong",[t._v("scu 有什么用？背后逻辑是什么？")])]),t._v(" "),a("ul",[a("li",[t._v("默认返回 true。父组件更新，所有子组件无条件更新")])]),t._v(" "),a("p",[a("strong",[t._v("既然 scu 这么好，为什么还给你提供自定义的能力，不给他直接实现到框架内部呢？")])]),t._v(" "),a("ul",[a("li",[t._v("因为一定要配合不可变值")]),t._v(" "),a("li",[t._v("所以有的开发者会使用不合规范的写法，导致不发生重渲染")])]),t._v(" "),a("p",[a("strong",[t._v("比较的时候如何有什么要注意的问题？")])]),t._v(" "),a("ul",[a("li",[t._v("用_.isEqual JSON.stringfy() 深度比较会非常耗费性能")]),t._v(" "),a("li",[t._v("所以设计 state 的时候不要层级太深")]),t._v(" "),a("li",[t._v("使用浅比较，浅比较已经适用大部分情况了")]),t._v(" "),a("li",[t._v("另外可以自定义比较")])]),t._v(" "),a("p",[t._v("当然如果真的想完整对比当前 "),a("code",[t._v("state")]),t._v(" 和之前的 "),a("code",[t._v("state")]),t._v(" 是否相同，并且不影响性能也是行得通的，可以通过 "),a("code",[t._v("immutable")]),t._v(" 或者 "),a("code",[t._v("immer")]),t._v(" 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 "),a("code",[t._v("state")]),t._v(" 是否一致也就方便多了，同时也很推荐阅读下 "),a("code",[t._v("immer")]),t._v(" 的源码实现。")]),t._v(" "),a("ul",[a("li",[t._v("彻底拥抱不可变值")]),t._v(" "),a("li",[t._v("解决了什么问题？深拷贝性能太差，immutable.js 基于共享数据和结构，性能好")]),t._v(" "),a("li",[t._v("有一定学习和使用成本")]),t._v(" "),a("li",[a("a",{attrs:{href:"https://github.com/mweststrate/immer",target:"_blank",rel:"noopener noreferrer"}},[t._v("Immer"),a("OutboundLink")],1),t._v(" 是 mobx 的作者写的一个 immutable 库，核心实现是利用 ES6 的 proxy，几乎以最小的成本实现了 js 的不可变数据结构")])]),t._v(" "),a("h2",{attrs:{id:"react-中-keys-的作用是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-中-keys-的作用是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" React 中 keys 的作用是什么？")]),t._v(" "),a("p",[a("code",[t._v("Keys")]),t._v("是 "),a("code",[t._v("React")]),t._v(" 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识")]),t._v(" "),a("ul",[a("li",[t._v("在开发过程中，我们需要保证某个元素的 "),a("code",[t._v("key")]),t._v(" 在其同级元素中具有唯一性。在 "),a("code",[t._v("React Diff")]),t._v(" 算法中"),a("code",[t._v("React")]),t._v(" 会借助元素的 "),a("code",[t._v("Key")]),t._v(" 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 "),a("code",[t._v("Key")]),t._v(" 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 "),a("code",[t._v("Key")]),t._v(" 的重要性")])]),t._v(" "),a("h2",{attrs:{id:"函数组件和-class-组件的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数组件和-class-组件的区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 函数组件和 class 组件的区别？")]),t._v(" "),a("ul",[a("li",[t._v("纯函数，输入 props，输出 JSX")]),t._v(" "),a("li",[t._v("没有实例，没有生命周期，没有 state")]),t._v(" "),a("li",[t._v("不能拓展其他方法")])]),t._v(" "),a("h2",{attrs:{id:"setstate-后发生了什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate-后发生了什么","aria-hidden":"true"}},[t._v("#")]),t._v(" setState 后发生了什么?")]),t._v(" "),a("p",[t._v("当给 setState 传入新对象时，React 内部会进行一种类似 Object.assign() 的方式对象合并，把需要更新的 state 合并后放入状态队列，利用这个队列可以更加高效的批量更新 state；当参数为函数时，React 会将所有更新组成队列，并且按顺序来执行，这样避免了将 state 合并成一个对象的问题，之后会启动一个"),a("code",[t._v("reconciliation")]),t._v("调和过程，即创建一个新的 React Element tree（UI 层面的对象表示）并且和之前的 tree 作比较，基于你传递给 setState 的对象找出发生的变化，最后更新 DOM 中需改动的部分。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/0082zybply1gc9gqugd88j30ht0cemz9.jpg",alt:"image-20200226074600085"}})]),t._v(" "),a("h2",{attrs:{id:"setstate-到底是异步还是同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setstate-到底是异步还是同步","aria-hidden":"true"}},[t._v("#")]),t._v(" setState 到底是异步还是同步?")]),t._v(" "),a("p",[t._v("看右边，开始处于 "),a("code",[t._v("batchUpdate")]),t._v(" 中，"),a("code",[t._v("isBatchingUpdates = true")]),t._v("，接着开始执行 "),a("code",[t._v("setTimeout")]),t._v("，但是里面的 "),a("code",[t._v("setState")]),t._v(" 是异步的，所以还没执行，紧接着 "),a("code",[t._v("isBatchingUpdates = false")]),t._v(" 。因此之后 "),a("code",[t._v("setState")]),t._v(" 执行的时候，"),a("code",[t._v("isBatchingUpdates = false")]),t._v(" ，所以开始走流程图的右边了。")]),t._v(" "),a("ul",[a("li",[t._v("同步异步不是由 setState 自己决定的")]),t._v(" "),a("li",[t._v("就是看能否命中 batchUpdate 机制")]),t._v(" "),a("li",[t._v("判断 "),a("code",[t._v("isBatchingUpdate")])])]),t._v(" "),a("p",[a("strong",[t._v("能命中 batchUpdate 机制：")])]),t._v(" "),a("ul",[a("li",[t._v("生命周期以及其调用的函数")]),t._v(" "),a("li",[t._v("React 中注册的事件（和它调用的函数）")]),t._v(" "),a("li",[t._v("React 可以“管理”的入口")])]),t._v(" "),a("p",[a("strong",[t._v("不能命中：")])]),t._v(" "),a("ul",[a("li",[t._v("setTimeout，setInterval（和它调用的函数）")]),t._v(" "),a("li",[t._v("自定义的 DOM 事件")]),t._v(" "),a("li",[t._v("React “管不到” 的入口，不是 React 那儿注册的")])]),t._v(" "),a("h2",{attrs:{id:"hoc-解决了什么问题？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hoc-解决了什么问题？","aria-hidden":"true"}},[t._v("#")]),t._v(" HOC 解决了什么问题？")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("现在如果我想给这个 "),a("code",[t._v("add")]),t._v(" 函数添加一个输出结果的功能，那么你可能会考虑我直接使用 "),a("code",[t._v("console.log")]),t._v(" 不就实现了么。说的没错，但是如果我们想做的"),a("strong",[t._v("更加优雅并且容易复用和扩展")]),t._v("，我们可以这样去做")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("withLog")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("wrapper")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" result "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("result"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" wrapper\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" withLogAdd "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("withLog")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("add"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("withLogAdd")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("ul",[a("li",[t._v("其实这个做法在函数式编程里称之为高阶函数，大家都知道 "),a("code",[t._v("React")]),t._v(" 的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。")]),t._v(" "),a("li",[t._v("其实 "),a("code",[t._v("HOC")]),t._v(" 和 "),a("code",[t._v("Vue")]),t._v(" 中的 "),a("code",[t._v("mixins")]),t._v(" 作用是一致的，并且在早期 "),a("code",[t._v("React")]),t._v(" 也是使用 "),a("code",[t._v("mixins")]),t._v(" 的方式。但是在使用 "),a("code",[t._v("class")]),t._v(" 的方式创建组件以后，"),a("code",[t._v("mixins")]),t._v(" 的方式就不能使用了，并且其实 "),a("code",[t._v("mixins")]),t._v(" 也是存在一些问题的，比如")])]),t._v(" "),a("ol",[a("li",[t._v("隐含了一些依赖，比如我在组件中写了某个 "),a("code",[t._v("state")]),t._v(" 并且在 "),a("code",[t._v("mixin")]),t._v(" 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 "),a("code",[t._v("mixin")]),t._v(" 中查找依赖")]),t._v(" "),a("li",[t._v("多个 "),a("code",[t._v("mixin")]),t._v(" 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。")]),t._v(" "),a("li",[t._v("雪球效应，虽然我一个组件还是使用着同一个 "),a("code",[t._v("mixin")]),t._v("，但是一个 "),a("code",[t._v("mixin")]),t._v(" 会被多个组件使用，可能会存在需求使得 "),a("code",[t._v("mixin")]),t._v(" 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本")])]),t._v(" "),a("blockquote",[a("p",[a("code",[t._v("HOC")]),t._v(" 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）")])]),t._v(" "),a("p",[t._v("抽离多个组件的公共逻辑")]),t._v(" "),a("ul",[a("li",[t._v("HOC")]),t._v(" "),a("li",[t._v("Render Props")])]),t._v(" "),a("h2",{attrs:{id:"state-和-props-有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-和-props-有什么区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" state 和 props 有什么区别？")]),t._v(" "),a("p",[t._v("一句话概括，props 是组件对外的接口，state 是组件对内的接口。")]),t._v(" "),a("p",[a("code",[t._v("state")]),t._v(" 的主要作用是用于组件保存、控制、修改"),a("em",[t._v("自己")]),t._v("的可变状态。"),a("code",[t._v("state")]),t._v(" 在组件内部初始化，可以被组件自身修改，而外部不能访问也不能修改。你可以认为 "),a("code",[t._v("state")]),t._v(" 是一个局部的、只能被组件自身控制的数据源。"),a("code",[t._v("state")]),t._v(" 中状态可以通过 "),a("code",[t._v("this.setState")]),t._v(" 方法进行更新，"),a("code",[t._v("setState")]),t._v(" 会导致组件的重新渲染。")]),t._v(" "),a("p",[a("code",[t._v("props")]),t._v(" 的主要作用是让使用该组件的父组件可以传入参数来配置该组件。它是外部传进来的配置参数，组件内部无法控制也无法修改。")]),t._v(" "),a("p",[a("code",[t._v("state")]),t._v(" 和 "),a("code",[t._v("props")]),t._v(" 有着千丝万缕的关系。它们都可以决定组件的行为和显示形态。一个组件的 "),a("code",[t._v("state")]),t._v(" 中的数据可以通过 "),a("code",[t._v("props")]),t._v(" 传给子组件，一个组件可以使用外部传入的 "),a("code",[t._v("props")]),t._v(" 来初始化自己的 "),a("code",[t._v("state")]),t._v("。但是它们的职责其实非常明晰分明："),a("em",[a("code",[t._v("state")]),t._v(" 是让组件控制自己的状态，"),a("code",[t._v("props")]),t._v(" 是让外部对组件自己进行配置")]),t._v("。")]),t._v(" "),a("p",[t._v("如果你觉得还是搞不清 "),a("code",[t._v("state")]),t._v(" 和 "),a("code",[t._v("props")]),t._v(" 的使用场景，那么请记住一个简单的规则：尽量少地用 "),a("code",[t._v("state")]),t._v("，尽量多地用 "),a("code",[t._v("props")]),t._v("。")]),t._v(" "),a("p",[t._v("没有 "),a("code",[t._v("state")]),t._v(" 的组件叫无状态组件（stateless component），设置了 state 的叫做有状态组件（stateful component）。因为状态会带来管理的复杂性，我们尽量多地写无状态组件，尽量少地写有状态的组件。这样会降低代码维护的难度，也会在一定程度上增强组件的可复用性。前端应用状态管理是一个复杂的问题，我们后续会继续讨论。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("场景")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("props")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("state")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("是否可以从父组件中获取初始值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("是否能被父组件改变")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("不可以")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("是否能设置默认值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("不可以")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("是否在组件里改变值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("不可以")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("能否给子组件设置初始值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("能否在子组件里被改变值")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("可以")])])])]),t._v(" "),a("p",[a("strong",[t._v("总结一下")]),t._v("：")]),t._v(" "),a("ol",[a("li",[t._v("props 用于定义外部接口，使用 state 来存储控制当前页面逻辑的数据；")]),t._v(" "),a("li",[t._v("props 的赋值是在父级组件，state 赋值在当前组件内部；")]),t._v(" "),a("li",[t._v("props 是不可变的，而 state 是可变的；")]),t._v(" "),a("li",[t._v("使用 props 比 state 会有更好的性能；")])]),t._v(" "),a("h2",{attrs:{id:"purecomponent-纯组件-和-memo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#purecomponent-纯组件-和-memo","aria-hidden":"true"}},[t._v("#")]),t._v(" PureComponent 纯组件 和 memo")]),t._v(" "),a("ul",[a("li",[t._v("PureComponent，memo 实现了 SCU 中的浅比较（只比较第一层）")]),t._v(" "),a("li",[t._v("memo 就是 PC 的函数组件版本")]),t._v(" "),a("li",[t._v("必须配合不可变值")])]),t._v(" "),a("h2",{attrs:{id:"什么是受控组件？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是受控组件？","aria-hidden":"true"}},[t._v("#")]),t._v(" 什么是受控组件？")]),t._v(" "),a("ul",[a("li",[t._v("表单的值，受 state 控制")]),t._v(" "),a("li",[t._v("需要自行监听 onChange 事件")]),t._v(" "),a("li",[t._v("对比非受控组件")])]),t._v(" "),a("h2",{attrs:{id:"react-router-如何配置懒加载？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-router-如何配置懒加载？","aria-hidden":"true"}},[t._v("#")]),t._v(" react-router 如何配置懒加载？")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://tva1.sinaimg.cn/large/00831rSTly1gcy3v85jpwj30tb0fsgtu.jpg",alt:"image-20200318151935024"}})]),t._v(" "),a("h2",{attrs:{id:"何为-fiber"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#何为-fiber","aria-hidden":"true"}},[t._v("#")]),t._v(" 何为 fiber")]),t._v(" "),a("p",[t._v("js 的单线程调度算法")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.im/post/5ab7b3a2f265da2378403e57",target:"_blank",rel:"noopener noreferrer"}},[t._v("fiber 介绍"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("react 在进行组件渲染时，从 setState 开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js 执行会占据主线程时间较长，会导致页面响应度变差，使得 react 在动画、手势等应用中效果比较差。")]),t._v(" "),a("p",[t._v("为了解决这个问题，react 团队经过两年的工作，重写了 react 中核心算法——"),a("a",{attrs:{href:"https://reactjs.org/docs/reconciliation.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("reconciliation"),a("OutboundLink")],1),t._v("。并在 v16 版本中发布了这个新的特性。为了区别之前和之后的 reconciler，通常将之前的 reconciler 称为 stack reconciler，重写后的称为 fiber reconciler，简称为 Fiber。")]),t._v(" "),a("ul",[a("li",[t._v("将 reconciliation（重写了） 阶段进行拆分（commit 无法拆分，一次执行完）")]),t._v(" "),a("li",[t._v("DOM 需要渲染时候暂停，空闲时恢复")]),t._v(" "),a("li",[t._v("何时暂停何时恢复呢？ "),a("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback",target:"_blank",rel:"noopener noreferrer"}},[t._v("window.requestIdleCallback"),a("OutboundLink")],1),t._v(" (Edge,IE,Safari 不支持，用 polyfill)")])]),t._v(" "),a("h2",{attrs:{id:"react-性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-性能优化","aria-hidden":"true"}},[t._v("#")]),t._v(" React 性能优化")]),t._v(" "),a("ul",[a("li",[t._v("减少 bind this")]),t._v(" "),a("li",[t._v("合理使用 SCU，Pure 和 memo")]),t._v(" "),a("li",[t._v("webpack 层面的优化")]),t._v(" "),a("li",[t._v("前端通用的，比如图片懒加载，base64，CSS")]),t._v(" "),a("li",[t._v("使用 SSR")])])])},[],!1,null,null,null);e.default=_.exports}}]);